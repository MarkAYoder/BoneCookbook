[[tips]]
== Beyond the Basics

=== Introduction
In <<basics>>, you learned how to set up BeagleBone Black, and <<sensors>>, <<displays>>, and <<motors>> showed how to interface to the physical world. <<networking>> through the remainder of the book moves into some more exciting advanced topics, and this chapter gets you ready for them.  

The recipes in this chapter assume that you are running Linux on your host computer (<<tips_pick_os>>) and are comfortable with using Linux. We continue to assume that you are logged in as +debian+ on your Bone.

[[tips_hdmi]]
=== Running Your Bone Standalone

==== Problem
((("advanced operations", "running standalone")))((("displays", "HDMI")))((("HDMI displays")))((("outputs", "microHDMI")))((("keyboards")))((("mouse")))You want to use BeagleBone Black as a desktop computer with keyboard, mouse, and an HDMI display.

==== Solution
The Bone comes with USB and a microHDMI output. All you need to do is connect your keyboard, mouse, and HDMI display to it. 

To make this recipe, you will need:

* Standard HDMI cable and female HDMI-to-male microHDMI adapter (see <<app_misc>>), or
* MicroHDMI-to-HDMI adapter cable (see <<app_misc>>)
* HDMI monitor (see <<app_misc>>)
* USB keyboard and mouse
* Powered USB hub (see <<app_misc>>)

[NOTE]
====
The microHDMI adapter is nice because it allows you to use a regular HDMI cable with the Bone. However, it will block other ports and can damage the Bone if you aren't careful. The microHDMI-to-HDMI cable won't have these problems.  
====

[TIP]
====
((("DVI-D displays")))((("displays", "DVI-D")))((("outputs", "DVI-D")))You can also use an HDMI-to-DVI cable (<<app_misc>>) and use your Bone with a DVI-D display.
====

The adapter looks something like <<tips_HDMI_adaptor_fig>>.

[[tips_HDMI_adaptor_fig]]
.Female HDMI-to-male microHDMI adapter
image::figures/hdmiConverter.jpg[HDMI Adaptor]

Plug the small end into the microHDMI input on the Bone and plug your HDMI cable into the other end of the adapter and your monitor. If nothing displays on your Bone, reboot.

If nothing appears after the reboot, edit the _/boot/uEnv.txt_ file. Search for the line containing +##Disable HDMI+ and add the following lines after it:

[source, console]
----
##Disable HDMI
#cape_disable=capemgr.disable_partno=BB-BONELT-HDMI,BB-BONELT-HDMIN
cape_disable=capemgr.disable_partno=BB-BONELT-HDMI
----

Then reboot.

////
PRODUCTION: in the following tip, we're trying to display the hash symbol (#), all by itself, in constant width. Using +#+ produces an empty space in the build, and I don't know how to escape special characters within what should be literal strings.

Adding to my confusion, the # signs are dropped in the first paragraph of the tip, but not in the second, which is formatted in the same exact way.

Also, using ## in the code italicizes the second # and everything after it in the line, which should not happen.
////

[TIP]
====
((("# character")))The _/boot/uEnv.txt_ file contains a number of configuration commands that are executed at boot time. The +&#35;+ character is used to add comments; that is, everything to the right of a +&#35;+ is ignored by the Bone and is assumed to be for humans to read. In the previous example, +&#35;&#35;Disable HDMI+ is a comment that informs us the next line(s) are for disabling the HDMI. Two +cape.disable+ commands follow. The first one is commented-out and won't be executed by the Bone.  

Why not just remove the first +cape.disable+?  Later, you might decide you need more general-purpose input/output (GPIO) pins and don't need the HDMI display. If so, just remove the +#+ from for first +cape.disble+. If you had completely removed the line earlier, you would have to look up the details somewhere to re-create it.  

When in doubt, comment-out; don't delete.
====

[NOTE]
====
If you want to re-enable the HDMI audio, just comment-out the line you added.
====

The Bone has only one USB port, so you will need to get either a keyboard with a USB hub (see <<app_misc>>) or a powered USB hub. Plug the USB hub into the Bone and then plug your keyboard and mouse in to the hub. You now have a Beagle workstation; no host computer is needed.

[TIP]
====
The powered hub is recommended because USB can supply only 500 mA, and you'll want to plug many things into the Bone.
====

==== Discussion
((("audio files", "HDMI audio")))((("files", "audio")))This recipe disables the HDMI audio, which allows the Bone to try other resolutions. If this fails, see http://bit.ly/1GEPcOH[BeagleBoneBlack HDMI] for how to force the Bone's resolution to match your monitor.

[[tips_pick_os]]
=== Selecting an OS for Your Development Host Computer

==== Problem
((("advanced operations", "selecting host computer OS")))((("host computer", "OS selection")))((("operating system (OS)", "selecting for host computer")))Your project needs a host computer, and you need to select an operating system (OS) for it.

==== Solution
For projects that require a host computer, we assume that you are running http://bit.ly/1wXOwkw[Linux Ubuntu 20.04 LTS]. You can be running either a native installation, through https://docs.microsoft.com/en-us/windows/wsl/[Windows Subsystem for Linux],via a virtual machine such as https://www.virtualbox.org/[VirtualBox], or in the cloud (https://portal.azure.com/[Microsoft Azure] or http://aws.amazon.com/ec2/[Amazon Elastic Compute Cloud] [EC2], for example).

Recently I've been prefering https://docs.microsoft.com/en-us/windows/wsl/[Windows Subsystem for Linux].

==== Discussion


[[tips_shell]]
=== Getting to the Command Shell via SSH

==== Problem
((("advanced operations", "accessing command shell via SSH")))((("SSH (Secure Shell)", "connecting via")))((("command shell, accessing")))You want to connect to the command shell of a remote Bone from your host pass:[<span class="keep-together">computer</span>].

==== Solution

((("superusers")))((("root user")))<<basics_cloud9_IDE>> shows how to run shell commands in the Cloud9 +bash+ tab. However, the Bone has Secure Shell (SSH) enabled right out of the box, so you can easily connect by using the following command to log in as user +debian+, (note the +$+ at the end of the prompt):

++++
<pre data-type="programlisting">
host$ <strong>ssh debian@192.168.7.2</strong>
Warning: Permanently added 'bone,192.168.7.2' (ECDSA) to the list of known hosts.
Last login: Mon Dec 22 07:53:06 2014 from yoder-linux.local
bone$ 
</pre>
++++

((("normal user")))((("Debian", "normal user")))Or you could log in as a normal user, +debian+ (note the +$+ at the end of the prompt):

((("passwords", "changing")))((("security issues", "passwords")))+root+ has passwords disabled. It's best to change the password:

++++
<pre data-type="programlisting">
bone$ <strong>passwd</strong>
Changing password for debian.
(current) UNIX password: 
Enter new UNIX password: 
Retype new UNIX password: 
passwd: password updated successfully
</pre>
++++

==== Discussion


[[tips_serial]]
=== Getting to the Command Shell via the Virtual Serial Port

==== Problem
((("advanced operations", "accessing command shell via virtual serial port")))((("command shell, accessing")))((("virtual serial port")))((("serial ports", "virtual")))You want to connect to the command shell of a remote Bone from your host computer without using SSH.

==== Solution
Sometimes, you can't connect to the Bone via SSH, but you have a network working over USB to the Bone. There is a way to access the command line to fix things without requiring extra hardware. (<<tips_FTDI>> shows a way that works even if you don't have a network working over USB, but it requires a special serial-to-USB cable.)

First, check to ensure that the serial port is there. On the host computer, run the following command:

++++
<pre data-type="programlisting">
host$ <strong>ls -ls /dev/ttyACM0</strong>
0 crw-rw---- 1 root dialout 166, 0 Jun 19 11:47 /dev/ttyACM0
</pre>
++++

_/dev/ttyACM0_ is a serial port on your host computer that the Bone creates when it boots up. 
The letters +crw-rw----+ show that you can't access it as a normal user. However, you _can_ access it if you are part of +dialout+ group. See if you are in the +dialout+ group:

++++
<pre data-type="programlisting">
host$ <strong>groups</strong>
yoder adm tty uucp <strong>dialout</strong> cdrom sudo dip plugdev lpadmin sambashare
</pre>
++++
Looks like I'm already in the group, but if you aren't, just add yourself to the group:

++++
<pre data-type="programlisting">
host$ <strong>sudo adduser $USER dialout</strong>
</pre>
++++

((("adduser")))You have to run +adduser+ only once. Your host computer will remember the next time you boot up. Now, install and run the +screen+ command:

++++
<pre data-type="programlisting">
host$ <strong>sudo apt install screen</strong>
host$ <strong>screen /dev/ttyACM0 115200</strong>
Debian GNU/Linux 7 beaglebone ttyGS0

default username:password is [debian:temppwd]

Support/FAQ: http://elinux.org/Beagleboard:BeagleBoneBlack_Debian

The IP Address for usb0 is: 192.168.7.2
beaglebone login:
</pre>
++++

The +/dev/ttyACM0+ parameter specifies which serial port to connect to, and +115200+ 
tells the speed of the connection. In this case, it's 115,200 bits per second.

==== Discussion


[[tips_FTDI]]
=== Viewing and Debugging the Kernel and u-boot Messages at Boot Time

==== Problem
((("advanced operations", "viewing system messages")))((("FTDI pins")))((("debugging", "low-level")))((("system messages, viewing")))((("debugging", "at boot time")))You want to see the messages that are logged by BeagleBone Black as it comes to life.

==== Solution
There is no network in place when the Bone first boots up, so <<tips_shell>> and <<tips_serial>> won't work. This recipe uses some extra hardware (FTDI cable) to attach to the Bone's console serial port.

To make this recipe, you will need:

* 3.3 V FTDI cable (see <<app_misc>>)

[WARNING]
====
Be sure to get a 3.3 V FTDI cable (shown in <<tips_FTDIcable_fig>>), because the 5 V cables won't work.
====

[TIP]
====
The Bone's Serial Debug J1 connector has Pin 1 connected to ground, Pin 4 to receive, and Pin 5 to transmit. The other pins are not attached.
====

[[tips_FTDIcable_fig]]
.FTDI cable
image::figures/FTDIcable.jpg[FTDI Cable]

Look for a small triangle at the end of the FTDI cable (<<tips_FTDIconnector_fig>>).  It's often connected to the black wire. 

[[tips_FTDIconnector_fig]]
.FTDI connector
image::figures/FTDIconnector.jpg[FTDI Connector]

Next, look for the FTDI pins of the Bone (labeled +J1+ on the Bone), shown in <<tips_black_hardware_details_fig>>.  
They are next to the P9 header and begin near pin 20. There is a white dot near P9_20. 

[[tips_black_hardware_details_fig]]
.FTDI pins for the FTDI connector footnote:[<<tips_black_hardware_details_fig>> was originally posted by Jason Kridner at http://beagleboard.org/media under a http://creativecommons.org/licenses/by-sa/3.0/[Creative Commons Attribution-ShareAlike 3.0 Unported License].]
image::figures/FTDIPins.png[Serial Debug Pins]

Plug the FTDI connector into the FTDI pins, being sure to connect the _triangle_ pin on the connector to the _white dot_ pin of the +FTDI+ connector.

Now, run the following commands on your host computer:

++++
<pre data-type="programlisting">
host$ <strong>ls -ls /dev/ttyUSB0</strong>
0 crw-rw---- 1 root dialout 188, 0 Jun 19 12:43 /dev/ttyUSB0
host$ <strong>sudo adduser $USER dialout</strong>
host$ <strong>screen /dev/ttyUSB0 115200</strong>
Debian GNU/Linux 7 beaglebone ttyO0

default username:password is [debian:temppwd]

Support/FAQ: http://elinux.org/Beagleboard:BeagleBoneBlack_Debian

The IP Address for usb0 is: 192.168.7.2
beaglebone login: 
</pre>
++++

[NOTE]
====
Your screen might initially be blank. Press Enter a couple times to see the login prompt.
====

==== Discussion


=== Verifying You Have the Latest Version of the OS on Your Bone from the Shell

==== Problem
((("advanced operations", "verifying OS version from the shell")))((("operating system (OS)", "verifying from the shell")))You are logged in to your Bone with a command prompt and want to know what version of the OS you are running.

==== Solution
Log in to your Bone and enter the following command:

// TODO update /etc/dogtag<

++++
<pre data-type="programlisting">
bone$ <strong>cat /etc/dogtag</strong>
BeagleBoard.org Debian Bullseye IoT Image 2022-06-02
</pre>
++++

==== Discussion
<<basics_latest_os>> shows how to open the _ID.txt_ file to see the OS version. The _/etc/dogtag_ file has the same contents and is easier to find if you already have a command prompt. See <<basics_install_os>> if you need to update your OS.

=== Controlling the Bone Remotely with a VNC

==== Problem
((("advanced operations", "remote control via VNC server")))((("Virtual Network Computing (VNC) server")))((("host computer", "accessing graphical desktop from")))You want to access the BeagleBone's graphical desktop from your host computer.

==== Solution
Run the installed Virtual Network Computing (VNC) server:

++++
<pre data-type="programlisting">
bone$ <strong>tightvncserver</strong>

You will require a password to access your desktops.

Password: 
Verify:   
Would you like to enter a view-only password (y/n)? n
xauth: (argv):1:  bad display name "beaglebone:1" in "add" command

New 'X' desktop is beaglebone:1

Creating default startup script /root/.vnc/xstartup
Starting applications specified in /root/.vnc/xstartup
Log file is /root/.vnc/beaglebone:1.log
</pre>
++++
// TODO - Start here

((("Remmina Remote Desktop Client")))To connect to the Bone, you will need to run a VNC client. There are many to choose from. Remmina Remote Desktop Client is already installed on Ubuntu. Start and select the new remote desktop file button (<<tips_vnc1_fig>>).

////
I fixed the wording here to better match the software.
////
[[tips_vnc1_fig]]
.Creating a new remote desktop file in Remmina Remote Desktop Client
image::figures/vnc1.png[Create a new remote desktop]

Give your connection a name, being sure to select "VNC - Virtual Network Computing." Also, be sure to add +:1+ after the server address, as shown in <<tips_vnc2_fig>>. This should match the +:1+ that was displayed when you started +vncserver+.

[[tips_vnc2_fig]]
.Configuring the Remmina Remote Desktop Client
image::figures/vnc2.png[Configuring]

Click Connect to start graphical access to your Bone, as shown in <<tips_vnc3_fig>>.

[[tips_vnc3_fig]]
.The Remmina Remote Desktop Client showing the BeagleBone desktop
image::figures/vnc3.png[Desktop]

[TIP]
====
You might need to resize the VNC screen on your host to see the bottom menu bar on your Bone. 
====

==== Discussion


=== Learning Typical GNU/Linux Commands

==== Problem
((("advanced operations", "GNU/Linux commands")))((("Linux", "common commands")))((("commands", "in Linux")))There are many powerful commands to use in Linux. How do you learn about them?

==== Solution
<<tips_linux_commands>> lists many common Linux commands.

[[tips_linux_commands]]
.Common Linux commands
[options="header"]
|=======
|Command|Action
|pwd|show current directory
|cd|change current directory
|ls|list directory contents
|chmod|change file permissions
|chown|change file ownership
|cp|copy files
|mv|move files
|rm|remove files
|mkdir|make directory
|rmdir|remove directory
|cat|dump file contents
|less|progressively dump file
|vi|edit file (complex)
|nano|edit file (simple)
|head|trim dump to top
|tail|trim dump to bottom
|echo|print/dump value
|env|dump environment variables
|export|set environment variable
|history|dump command history
|grep|search dump for strings
|man|get help on command
|apropos|show list of man pages
|find|search for files
|tar|create/extract file archives
|gzip|compress a file
|gunzip|decompress a file
|du|show disk usage
|df|show disk free space
|mount|mount disks
|tee|write dump to file in parallel
|hexdump|readable binary dumps
|whereis|locates binary and source files
|=======

==== Discussion

[[tips_editing_files]]
=== Editing a Text File from the GNU/Linux Command Shell

==== Problem
((("advanced operations", "editing text file from GNU/Linux command shell")))((("files", "editing text")))((("text files, editing")))((("nano editor")))((("editors", "text-based")))You want to run an editor to change a file.

==== Solution
The Bone comes with a number of editors. The simplest to learn is +nano+. Just enter the following command:

++++
<pre data-type="programlisting">
bone$ <strong>nano file</strong>
</pre>
++++

You are now in nano (<<tips_nano_fig>>). You can't move around the screen using the mouse, so use the arrow keys. The bottom two lines of the screen list some useful commands. Pressing &#708;G (Ctrl-G) will display more useful commands. &#708;X (Ctrl-X) exits nano and gives you the option of saving the file.

[[tips_nano_fig]]
.Editing a file with nano
image::figures/nano.png[nano]

[TIP]
====
By default, the file you create will be saved in the directory from which you opened +nano+.
====

==== Discussion

Many other text editors will run on the Bone. +vi+, +vim+, +emacs+, and  even +eclipse+ are all supported. See <<tips_apt>> to learn if your favorite is one of them.


[[networking_wired]]
=== Establishing an Ethernet-Based Internet Connection

==== Problem
((("advanced operations", "Ethernet-based Internet connections")))((("Internet", "Ethernet-based connections")))You want to connect your Bone to the Internet using the wired network connection.

==== Solution
((("RJ45 connector")))Plug one end of an Ethernet patch cable into the RJ45 connector on the Bone (see <<networking_rj45>>) and the other end into your home hub/router. The yellow and green link lights on both ends should begin to flash.

[[networking_rj45]]
.The RJ45 port on the Bone
image::figures/internLED.png[RJ45]

((("DHCP (Dynamical Host Configuration Protocol)")))If your router is already configured to run DHCP (Dynamical Host Configuration Protocol), it will automatically assign an IP address to the Bone. 

[WARNING]
====
It might take a minute or two for your router to detect the Bone and assign the IP address.
====

((("IP address", "locating")))((("ifconfig command")))To find the IP address, open a terminal window and run the +ip+ command:

++++
<pre data-type="programlisting">
bone$ <strong>ip a</strong>
1: lo: <LOOPBACK,UP,LOWER_UP> mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000
    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
    inet 127.0.0.1/8 scope host lo
       valid_lft forever preferred_lft forever
    inet6 ::1/128 scope host 
       valid_lft forever preferred_lft forever
2: eth0: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc mq state UP group default qlen 1000
    link/ether c8:a0:30:a6:26:e8 brd ff:ff:ff:ff:ff:ff
    inet 10.0.5.144/24 brd 10.0.5.255 scope global dynamic eth0
       valid_lft 80818sec preferred_lft 80818sec
    inet6 fe80::caa0:30ff:fea6:26e8/64 scope link 
       valid_lft forever preferred_lft forever
3: usb0: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc pfifo_fast state UP group default qlen 1000
    link/ether c2:3f:44:bb:41:0f brd ff:ff:ff:ff:ff:ff
    inet 192.168.7.2/24 brd 192.168.7.255 scope global usb0
       valid_lft forever preferred_lft forever
    inet6 fe80::c03f:44ff:febb:410f/64 scope link 
       valid_lft forever preferred_lft forever
4: usb1: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc pfifo_fast state UP group default qlen 1000
    link/ether 76:7e:49:46:1b:78 brd ff:ff:ff:ff:ff:ff
    inet 192.168.6.2/24 brd 192.168.6.255 scope global usb1
       valid_lft forever preferred_lft forever
    inet6 fe80::747e:49ff:fe46:1b78/64 scope link 
       valid_lft forever preferred_lft forever
5: can0: <NOARP,ECHO> mtu 16 qdisc noop state DOWN group default qlen 10
    link/can 
6: can1: <NOARP,ECHO> mtu 16 qdisc noop state DOWN group default qlen 10
    link/can
</pre>
++++

My Bone is connected to the Internet in two ways: via the RJ45 connection (+eth0+) and via the USB cable (+usb0+). The +inet+ field shows that my Internet address is +10.0.5.144+ for the RJ45 connector.

((("MAC address, locating")))On my university campus, you must register your MAC address before any device will work on the network. The +HWaddr+ field gives the MAC address. For +eth0+, it's +c8:a0:30:a6:26:e8+.  

The IP address of your Bone can change. If it's been assigned by DHCP, it can change at any time. The MAC address, however, never changes;  it is assigned to your ethernet device when it's manufactured.

[WARNING]
====
When a Bone is connected to some networks (in my case, the campus network), 
it becomes visible to the _world_. If you don't secure your Bone, the world will soon find it. See <<tips_passwords>> and <<tips_firewall>>. 

On many home networks, you will be behind a firewall and won't be as visible.
====

==== Discussion


[[networking_wireless]]
=== Establishing a WiFi-Based Internet Connection

==== Problem
((("Internet", "WiFi-based connections")))((("USB wireless adapters")))((("WiFi adapters")))((("wireless networks, connecting to")))((("advanced operations", "WiFi-based Internet connections")))You want BeagleBone Black to talk to the Internet using a USB wireless adapter.

==== Solution

[TIP]
====
For the correct instructions for the image you are using, go to
https://forum.beagleboard.org/tag/latest-images[latest-images] and click on the image you are using.  

I'm running Debian 11.x (Bullseye), the middle one.

[[tips_latest-images_fig]]
.Latested Beagle Images
image::figures/latest-images.png[Latest Image Page]

Scroll to the top of the page and you'll see instructions on setting up Wifi. The instructions here are based on using +networkctl+

[[tips_networkfig]]
.Instructions for setting up your network.
image::figures/network.png[Network Setup Instructions]
====

// TODO is this up to date?
Several WiFi adapters work with the Bone. Check http://bit.ly/1EbEwUo[WiFi Adapters] for the latest list.

To make this recipe, you will need:

* USB Wifi adapter (see <<app_misc>>)
* 5 V external power supply (see <<app_misc>>)

[WARNING]
====
((("external power supplies")))((("power supplies, external")))Most adapters need at least 1 A of current to run, and USB supplies only 0.5 A, so be sure to use an external power supply. Otherwise, you will experience erratic behavior and random crashes.
====

First, plug in the WiFi adapter and the 5 V external power supply and reboot.

Then run +lsusb+ to ensure that your Bone found the adapter:

++++
<pre data-type="programlisting">
bone$ <strong>lsusb</strong>
Bus 001 Device 002: ID 0bda:8176 Realtek Semiconductor Corp. RTL8188CUS 802.11n 
WLAN Adapter
Bus 001 Device 001: ID 1d6b:0002 Linux Foundation 2.0 root hub
Bus 002 Device 001: ID 1d6b:0002 Linux Foundation 2.0 root hub
</pre>
++++

[NOTE]
====
((("USB devices")))There is a well-known bug in the Bone's 3.8 kernel series that prevents USB devices from being discovered when hot-plugged, which is why you should reboot. Newer kernels should address this issue.
====

// TODO  update



((("iwconfig command")))Next, run +networkctl+ to find your adapter's name.  Mine is called +wlan0+, but you might see other names, such as +ra0+.

++++
<pre data-type="programlisting">
bone$ <strong>networkctl</strong>
IDX LINK    TYPE     OPERATIONAL SETUP
  1 lo      loopback carrier     unmanaged
  2 eth0    ether    no-carrier  configuring
  3 usb0    gadget   routable    configured 
  4 usb1    gadget   routable    configured 
  5 can0    can      off         unmanaged
  6 can1    can      off         unmanaged
  7 wlan0   wlan     routable    configured 
  8 SoftAp0 wlan     routable    configured 

8 links listed.
</pre>
++++

((("ifconfig command")))If no name appears, try +ip a+:

++++
<pre data-type="programlisting">
bone$ <strong>ip a</strong>
...
2: eth0: <NO-CARRIER,BROADCAST,MULTICAST,UP> mtu 1500 qdisc pfifo_fast state DOWN group default qlen 1000
    link/ether c8:a0:30:a6:26:e8 brd ff:ff:ff:ff:ff:ff
3: usb0: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc pfifo_fast state UP group default qlen 1000
    link/ether c2:3f:44:bb:41:0f brd ff:ff:ff:ff:ff:ff
    inet 192.168.7.2/24 brd 192.168.7.255 scope global usb0
       valid_lft forever preferred_lft forever
    inet6 fe80::c03f:44ff:febb:410f/64 scope link 
       valid_lft forever preferred_lft forever
...
7: wlan0: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc mq state UP group default qlen 1000
    link/ether 64:69:4e:7e:5c:e4 brd ff:ff:ff:ff:ff:ff
    inet 10.0.7.21/24 brd 10.0.7.255 scope global dynamic wlan0
       valid_lft 85166sec preferred_lft 85166sec
    inet6 fe80::6669:4eff:fe7e:5ce4/64 scope link 
       valid_lft forever preferred_lft forever
</pre>
++++

Next edit the configuration file +/etc/wpa_supplicant/wpa_supplicant-wlan0.conf+.

++++
<pre data-type="programlisting">
bone$ <strong>sudo nano /etc/wpa_supplicant/wpa_supplicant-wlan0.conf</strong>
</pre>
++++

In the file you'll see:

++++
<pre data-type="programlisting">
ctrl_interface=DIR=/run/wpa_supplicant GROUP=netdev
update_config=1
#country=US

network={
	ssid="Your SSID"
	psk="Your Password"
}
</pre>
++++

Change the +ssid+ and +psk+ enteries for your network. Save your file, then run:

++++
<pre>
bone$ <strong>sudo systemctl restart systemd-networkd</strong>
bone$ <strong> ip a</strong>
bone$ <strong>ping -c2 google.com</strong>
PING google.com (142.250.191.206) 56(84) bytes of data.
64 bytes from ord38s31-in-f14.1e100.net (142.250.191.206): icmp_seq=1 ttl=115 time=19.5 ms
64 bytes from ord38s31-in-f14.1e100.net (142.250.191.206): icmp_seq=2 ttl=115 time=19.4 ms

--- google.com ping statistics ---
2 packets transmitted, 2 received, 0% packet loss, time 1001ms
rtt min/avg/max/mdev = 19.387/19.450/19.513/0.063 ms
</pre>
++++

+wlan0+ should now have an ip address and you should be on the network. If not, try rebooting.

==== Discussion


[[networking_usb]]
=== Sharing the Host's Internet Connection over USB

// TODO  Test this

==== Problem
((("advanced operations", "sharing host&#x27;s Internet connection over USB")))((("host computer", "sharing Internet connection over USB")))((("RJ45 connector")))((("Internet", "sharing host computer&#x27;s connection")))Your host computer is connected to the Bone via the USB cable, and you want to run the network between the two.

==== Solution
<<networking_wired>> shows how to connect BeagleBone Black to the Internet via the RJ45 Ethernet connector.  This recipe shows a way to connect without using the RJ45 pass:[<span class="keep-together">connector</span>].

((("IP address", "locating")))A network is automatically running between the Bone and the host computer at boot time using the USB. The host's IP address is +192.168.7.1+ and the Bone's is +192.168.7.2+.  Although your Bone is talking to your host, it can't reach the Internet in general, nor can the Internet reach it. On one hand, this is good, because those who are up to no good can't access your Bone. On the other hand, your Bone can't reach the rest of the world.

===== Letting your bone see the world: setting up IP masquerading
((("IP address", "masquerading")))((("masquerading")))You need to set up IP masquerading on your host and configure your Bone to use it. Here is a solution that works with a host computer running Linux. Add the code in <<tips_ipmasq_code>> to a file called _ipMasquerade.sh_ on your host computer.

[[tips_ipmasq_code]]
.Code for IP Masquerading (ipMasquerade.sh)
====
[source, javascript]
----

include::code/ipMasquerade.sh[IP masquerade]

----
====

Then, on your host, run the following commands:

++++
<pre data-type="programlisting">
host$ <strong>chmod +x ipMasquerade.sh</strong>
host$ <strong>./ipMasquerade.sh eth0</strong>
</pre>
++++

This will direct your host to take requests from the Bone and send them to +eth0+. If your host is using a wireless connection, change +eth0+ to +wlan0+.

Now let's set up your host to instruct the Bone what to do. Add the code in <<tips_setDNS>> to _setDNS.sh_ on your host computer.

[[tips_setDNS]]
.Code for setting the DNS on the Bone (setDNS.sh)
====
[source, javascript]
----

include::code/setDNS.sh[Set DNS]

----
====

Then, on your host, run the following commands:

++++
<pre data-type="programlisting">
host$ <strong>chmod +x setDNS.sh</strong>
host$ <strong>./setDNS.sh</strong>
host$ <strong>ssh -X root@192.168.7.2</strong>
bone$ <strong>ping -c2 google.com</strong>
PING google.com (216.58.216.96) 56(84) bytes of data.
64 bytes from ord30s22....net (216.58.216.96): icmp_req=1 ttl=55 time=7.49 ms
64 bytes from ord30s22....net (216.58.216.96): icmp_req=2 ttl=55 time=7.62 ms

--- google.com ping statistics ---
2 packets transmitted, 2 received, 0% packet loss, time 1002ms
rtt min/avg/max/mdev = 7.496/7.559/7.623/0.107 ms
</pre>
++++

((("Domain Name System (DNS) servers")))This will look up what Domain Name System (DNS) servers your host is using and copy them to the right place on the Bone.  The +ping+ command is a quick way to verify your connection.

===== Letting the world see your bone: setting up port forwarding
((("ports", "port forwarding")))Now your Bone can access the world via the USB port and your host computer, but
what if you have a web server on your Bone that you want to access from the world?
The solution is to use _port forwarding_ from your host. 
Web servers typically listen to port +80+. First, look up the IP address of your host:

++++
<pre data-type="programlisting">
host$ <strong>ifconfig</strong>
eth0      Link encap:Ethernet  HWaddr 00:e0:4e:00:22:51  
          inet addr:<strong>137.112.41.35</strong>  Bcast:137.112.41.255  Mask:255.255.255.0
          inet6 addr: fe80::2e0:4eff:fe00:2251/64 Scope:Link
          UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1
          RX packets:5371019 errors:0 dropped:0 overruns:0 frame:0
          TX packets:4720856 errors:0 dropped:0 overruns:0 carrier:0
          collisions:0 txqueuelen:1000 
          RX bytes:1667916614 (1.6 GB)  TX bytes:597909671 (597.9 MB)

eth1      Link encap:Ethernet  HWaddr 00:1d:60:40:58:e6   
...
</pre>
++++

It's the number following +inet addr:+, which in my case is +137.112.41.35+. 

[TIP]
====
If you are on a wireless network, find the IP address associated with +wlan0+.
====

Then run the following, using your host's IP address:
//  TODO check this iptables
++++
<pre data-type="programlisting">
host$ <strong>sudo iptables -t nat -A PREROUTING -p tcp -s 0/0 \
     -d 137.112.41.35 --dport 1080 -j DNAT --to 192.168.7.2:80</strong>
</pre>
++++

Now browse to your host computer at port +1080+. That is, if your host's IP address is +123.456.789.0+, enter +123.456.789.0:1080+. The +:1080+ specifies what port number to use. The request will be forwarded to the server on your Bone listening to port +80+. (I used +1080+ here, in case your host is running a web server of its own on port +80+.)

==== Discussion

[[tips_firewall]]
=== Setting Up a Firewall

==== Problem
((("firewalls")))((("advanced operations", "firewalls")))((("iptables command")))((("commands", "iptables")))You have put your Bone on the network and want to limit which IP addresses can access it.

==== Solution
https://www.howtogeek.com/[How-To Geek] has a great posting on how do use +ufw+, the "uncomplicated firewall". Check out https://www.howtogeek.com/devops/how-to-secure-your-linux-server-with-a-ufw-firewall/[How to Secure Your Linux Server with a UFW Firewall].  I'll summarize the initial setup here.

First install and check the status:
++++
<pre data-type="programlisting">
bone$ <strong>sudo apt install ufw</strong>
bone$ <strong>sudo ufw status</strong>
Status: inactive
</pre>
++++

Now turn off everything coming in and leave on all outgoing.  Note, this won't take effect until +ufw+ is enabled.
++++
<pre data-type="programlisting">
bone$ <strong>sudo ufw default deny incoming</strong>
bone$ <strong>sudo ufw default allow outgoing</strong>
</pre>
++++

Don't enable yet, make sure +ssh+ still has access
++++
<pre data-type="programlisting">
bone$ <strong>sudo ufw allow 22</strong>
</pre>
++++

Just to be sure, you can install +nmap+ on your host computer to see what ports are currently open.

++++
<pre data-type="programlisting">
host$ <strong>sudo apt uupdate</strong>
host$ <strong>sudo apt install nmap</strong>
host$ <strong>nmap 192.168.7.2</strong>
Starting Nmap 7.80 ( https://nmap.org ) at 2022-07-09 13:37 EDT
Nmap scan report for bone (192.168.7.2)
Host is up (0.014s latency).
Not shown: 997 closed ports
PORT     STATE SERVICE
22/tcp   open  ssh
80/tcp   open  http
3000/tcp open  ppp

Nmap done: 1 IP address (1 host up) scanned in 0.19 seconds
</pre>
++++
Currently there are three ports visible:  22, 80 and 3000(visual studio code) Now turn on the firewal and see what happends.

++++
<pre data-type="programlisting">
bone$ <strong>sudo ufw enable</strong>
Command may disrupt existing ssh connections. Proceed with operation (y|n)? y
Firewall is active and enabled on system startup


host$ <strong>nmap 192.168.7.2</strong>
Starting Nmap 7.80 ( https://nmap.org ) at 2022-07-09 13:37 EDT
Nmap scan report for bone (192.168.7.2)
Host is up (0.014s latency).
Not shown: 999 closed ports
PORT     STATE SERVICE
22/tcp   open  ssh

Nmap done: 1 IP address (1 host up) scanned in 0.19 seconds
</pre>
++++

Only port 22 (ssh) is accessable now.  

The firewall will remain on, even after a reboot. Disable it now if you don't want it on.

++++
<pre data-type="programlisting">
bone$ <strong>sudo ufw disable</strong>
Firewall stopped and disabled on system startup
</pre>
++++

See the How-To Geek article for more examples.

==== Discussion


[[tips_apt]]
=== Installing Additional Packages from the Debian Package Feed

==== Problem
((("advanced operations", "installing additional packages")))((("Debian", "package manager")))((("programs", "installing")))((("software", "installing packages")))You want to do more cool things with your BeagleBone by installing more programs.

==== Solution
[WARNING]
====
Your Bone needs to be on the network for this to work. See <<networking_wired>>, <<networking_wireless>>, or <<networking_usb>>.
====

((("apt", "installing packages with")))The easiest way to install more software is to use +apt+:

++++
<pre data-type="programlisting">
bone$ <strong>sudo apt update</strong>
bone$ <strong>sudo apt install "name of software"</strong>
</pre>
++++

A +sudo+ is necessary since you aren't running as +root+. The first command downloads package lists from various repositories and updates them to get information on the newest versions of packages and their dependencies. (You need to run it only once a week or so.) The second command fetches the software and installs it and all packages it depends on. 

How do you find out what software you can install?  Try running this:

++++
<pre data-type="programlisting">
bone$ <strong>apt-cache pkgnames | sort > /tmp/list</strong>
bone$ <strong>wc /tmp/list</strong>
  67303   67303 1348342 /tmp/list
bone$ <strong>less /tmp/list</strong>
</pre>
++++

The first command lists all the packages that +apt+ knows about and sorts them and stores them in _/tmp/list_. The second command shows why you want to put the list in a file. The +wc+ command counts the number of lines, words, and characters in a file. In our case, there are over 67,000 packages from which we can choose! The +less+ command displays the sorted list, one page at a time. Press the space bar to go to the next page. Press Q to quit.  

((("dictionary, installing")))((("online dictionary, installing")))Suppose that you would like to install an online dictionary (+dict+). Just run the following command:

++++
<pre data-type="programlisting">
bone$ <strong>sudo apt install dict</strong>
</pre>
++++

Now you can run +dict+. 

==== Discussion


[[tips_apt_remove]]
=== Removing Packages Installed with apt

==== Problem
((("software", "removing packages")))((("advanced operations", "removing packages")))((("apt", "removing packages installed with")))((("programs", "removing")))You've been playing around and installing all sorts of things with +apt+ and now you want to clean things up a bit.

==== Solution
((("remove option")))+apt+ has a +remove+ option, so you can run the following command:

++++
<pre data-type="programlisting">
bone$ <strong>sudo apt remove dict</strong>
Reading package lists... Done
Building dependency tree       
Reading state information... Done
The following packages were automatically installed and are no longer required:
  libmaa3 librecode0 recode
Use 'apt autoremove' to remove them.
The following packages will be REMOVED:
  dict
0 upgraded, 0 newly installed, 1 to remove and 27 not upgraded.
After this operation, 164 kB disk space will be freed.
Do you want to continue [Y/n]? <strong>y</strong>
</pre>
++++

==== Discussion


=== Copying Files Between the Onboard Flash and the MicroSD Card

==== Problem
((("advanced operations", "copying files")))((("files", "copying")))((("onboard flash", "copying files to/from")))((("microSD card", "copying files to/from")))((("SD cards", "copying files to/from")))You want to move files between the onboard flash and the microSD card.

==== Solution
If you booted from the microSD card, run the following command:

++++
<pre data-type="programlisting">
bone$ <strong>df -h</strong>
Filesystem      Size  Used Avail Use% Mounted on
rootfs          7.2G  2.0G  4.9G  29% /
udev             10M     0   10M   0% /dev
tmpfs           100M  1.9M   98M   2% /run
/dev/mmcblk0p2  7.2G  2.0G  4.9G  29% /
tmpfs           249M     0  249M   0% /dev/shm
tmpfs           249M     0  249M   0% /sys/fs/cgroup
tmpfs           5.0M     0  5.0M   0% /run/lock
tmpfs           100M     0  100M   0% /run/user
bone$ <strong>ls /dev/mmcblk*</strong>
/dev/mmcblk0    /dev/mmcblk0p2  /dev/mmcblk1boot0  /dev/mmcblk1p1
/dev/mmcblk0p1  /dev/mmcblk1    /dev/mmcblk1boot1
</pre>
++++

((("df command")))((("commands", "df")))The +df+ command shows what partitions are already mounted. The line +/dev/mmcblk0p2  7.2G  2.0G  4.9G  29% /+ shows that +mmcblk0+ partition +p2+ is mounted as +/+, the root file system. The general rule is that the media you're booted from (either the onboard flash or the microSD card) will appear as +mmcblk0+. The second partition (+p2+) is the root of the file system. 

((("ls command")))((("commands", "ls")))The +ls+ command shows what devices are available to mount. Because +mmcblk0+ is already mounted, +/dev/mmcblk1p1+ must be the other media that we need to mount. Run the following commands to mount it:

++++
<pre data-type="programlisting">
bone$ <strong>cd /mnt</strong>
bone$ <strong>mkdir onboard</strong>
bone$ <strong>ls onboard</strong>
bone$ <strong>mount /dev/mmcblk1p1 onboard/</strong>
bone$ <strong>ls onboard</strong>
bin   etc     lib         mnt           proc  sbin     sys  var
boot  home    lost+found  nfs-uEnv.txt  root  selinux  tmp
dev   ID.txt  media       opt           run   srv      usr
</pre>
++++

((("cd (change directory) command")))((("commands", "cd (change directory)")))((("commands", "mkdir (make directory)")))((("mkdir (make directory) command")))((("commands", "mount")))((("mount command")))The +cd+ command takes us to a place in the file system where files are commonly mounted. The +mkdir+ command creates a new directory (_onboard_) to be a mount point. The +ls+ command shows there is nothing in _onboard_. The +mount+ command makes the contents of the onboard flash accessible. The next +ls+ shows there now are files in _onboard_. These are the contents of the onboard flash, which can be copied to and from like any other file.

==== Discussion
This same process should also work if you have booted from the onboard flash. When you are done with the onboard flash, you can unmount it by using this command:

++++
<pre data-type="programlisting">
bone$ <strong>umount /mnt/onboard</strong>
</pre>
++++

=== Freeing Space on the Onboard Flash or MicroSD Card

==== Problem
((("advanced operations", "freeing memory space")))((("onboard flash", "freeing space on")))((("microSD card", "freeing space on")))((("SD cards", "freeing space on")))((("software", "removing preinstalled")))You are starting to run out of room on your microSD card (or onboard flash) and have removed several packages you had previously installed (<<tips_apt_remove>>), but you still need to free up more space.

==== Solution 

To free up space, you can remove preinstalled packages or discover big files to remove.

===== Removing preinstalled packages

You might not need a few things that come preinstalled in the Debian image, including such things as OpenCV, the Chromium web browser, and some documentation. 

[NOTE]
====
((("Chromium web browser")))((("web browsers", "Chrome Chromium")))The Chromium web browser is the open source version of Google's Chrome web browser. Unless you are using the Bone as a desktop computer, you can probably remove it.

http://opencv.org/[OpencCV] is an open source computer vision package. If you aren't doing computer vision, you can remove it.
====

Here's how you can remove these:

++++
<pre data-type="programlisting">
bone$ <strong>sudo apt autoremove opencv*</strong>          (83M)
bone$ <strong>sudo apt remove libopencv-* --purge</strong>  (41M)
bone$ <strong>sudo apt autoremove</strong>                  (42M)
bone$ <strong>rm -rf /usr/lib/chromium</strong>            (95M)
bone$ <strong>rm -f  /usr/bin/chromium</strong>
bone$ <strong>rm -rf /usr/share/doc</strong>               (101M)
bone$ <strong>rm -rf /usr/share/man</strong>               (27M)
</pre>
++++

[NOTE]
====
These packages and sizes to remove were found in a http://bit.ly/1HC96aI[BeagleBoard Google Groups thread].
====

===== Discovering big files

((("files", "discovering large")))((("du (disk usage) command")))((("commands", "du (disk usage)")))((("disk space, determining")))The +du+ (disk usage) command offers a quick way to discover big files:

++++
<pre data-type="programlisting">
bone$ <strong>du -shx /*</strong>
5.6M	/bin
11M	/boot
0	/dev
5.4M	/etc
232K	/home
66M	/lib
16K	/lost+found
388M	/media
4.0K	/mnt
63M	/opt
du: cannot access `/proc/20551/task/20551/fd/3': No such file or directory
du: cannot access `/proc/20551/task/20551/fdinfo/3': No such file or directory
du: cannot access `/proc/20551/fd/3': No such file or directory
du: cannot access `/proc/20551/fdinfo/3': No such file or directory
0	/proc
227M	/root
1.1M	/run
5.0M	/sbin
4.0K	/selinux
4.0K	/srv
0	/sys
36K	/tmp
1.2G	/usr
143M	/var
</pre>
++++

If you booted from the microSD card, +du+ lists the usage of the microSD. If you booted from the onboard flash, it lists the onboard flash usage.

((("directories", "determining size of")))The +-s+ option summarizes the results rather than displaying every file. +-h+ prints it in _human_ form--that is, using +M+ and +K+ postfixes rather than showing lots of digits. The +/*+ specifies to run it on everything in the top-level directory. It looks like a couple of things disappeared while the command was running and thus produced some error messages.

[TIP]
====
For more help, try +du --help+.
====

The _/usr_ directory appears to be the biggest user of space at 1.2 GB. You can then run the following command to see what's taking up the space in _/usr_:

++++
<pre data-type="programlisting">
bone$ <strong>du -sh /usr/*</strong>
46M	/usr/bin
4.0K	/usr/games
36M	/usr/include
424M	/usr/lib
16M	/usr/local
4.0M	/usr/sbin
694M	/usr/share
4.0K	/usr/src
</pre>
++++

A more interactive way to explore your disk usage is by installing +ncdu+ (ncurses disk usage):

++++
<pre data-type="programlisting">
bone$ <strong>sudo apt install ncdu</strong>
bone$ <strong>ncdu /</strong>
</pre>
++++

After a moment, you'll see the following:

[source, console]
----
ncdu 1.8 ~ Use the arrow keys to navigate, press ? for help                     
--- / --------------------------------------------------------------------------
    1.2GiB [##########] /usr
  387.6MiB [###       ] /media
  226.0MiB [#         ] /root
  142.9MiB [#         ] /var
   65.9MiB [          ] /lib
   62.4MiB [          ] /opt
   10.8MiB [          ] /boot
    5.6MiB [          ] /bin
    5.4MiB [          ] /etc
    5.0MiB [          ] /sbin
    1.0MiB [          ] /run
  232.0KiB [          ] /home
   36.0KiB [          ] /tmp
e  16.0KiB [          ] /lost+found
e   4.0KiB [          ] /srv
e   4.0KiB [          ] /selinux
e   4.0KiB [          ] /mnt
    0.0  B [          ] /sys
    0.0  B [          ] /proc
    0.0  B [          ] /dev

 Total disk usage:   2.1GiB  Apparent size:   1.9GiB  Items: 156583
----

+ncdu+ is a character-based graphics interface to +du+.  You can now use your arrow keys to navigate the file structure to discover where the big unused files are. Press ? for help.

[WARNING]
====
((("D (delete) key")))((("files", "deleting")))((("directories", "deleting")))Be careful not to press the D key, because it's used to delete a file or directory.
====

==== Discussion


[[misc_libsoc]]
=== Using C to Interact with the Physical World

==== Problem
((("advanced operations", "interactions via C")))((("C language", "benefits of interfacing via")))((("libsoc library")))You want to use C on the Bone to talk to the world.

==== Solution
The C solution isn't as simple as the JavaScript or Python solution, but it does work and is much faster.  The approach is the same, write to the +/sys/class/gpio+ files.

[[misc_c_blink]]
.Use C to blink an LED (blinkLED.c)
====
[source, c]
----

include::code/blinkLED.c[]

----
====

Here, as with JavaScript and Python, the gpio pins are refered to by the Linux gpio number.  <<tips_cape_headers_digital>> shows how the P8 and P9 Headers numbers map to the gpio number.  For this example P9_14 is used, which the table shows in gpio 50.

[[tips_cape_headers_digital]]
.Mapping from header pin to internal GPIO number
image::figures/cape-headers-digital.png[cape headers digital]

Compile and run the code:

++++
<pre data-type="programlisting">
bone$ <strong>gcc -o blinkLED blinkLED.c </strong>
bone$ <strong>./blinkLED</strong>
^C
</pre>
++++

Hit ^C to stop the blinking.

==== Discussion
